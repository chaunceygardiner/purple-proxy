#!/usr/bin/perl

# Copyright (c) 2020 John A Kline
# See the file LICENSE for your full rights.


use strict;

my %counts;
my %errors;

# keys for individual counts
my $STARTUPS = 'Startups';
my $LONG_SENSOR_READS = 'Long Sensor Reads';
my $ARCHIVE_RECORDS_ADDED = 'Archive Records Added';
my $READ_TIMEOUTS = 'Read timeouts (skipped reading)';
my $ARCHIVE_INSERT_ERRORS = 'Archive Insert Errors';
my $TWO_MINUTE_INSERT_ERRORS = 'Two Minute Insert Errors';
my $CURRENT_INSERT_ERRORS = 'Current Insert Errors';
my $TMP_NAME_RESOLUTON_ERRORS = 'Tmp Name Resolution Errors';
my $NO_ROUTE_TO_HOST_ERRORS = 'No Route to Host';
my $SKIPPED_ARCHIVE_RECORDS = 'Skipped archive records';
my $SKIPPED_2M_RECORDS = 'Skipped 2 min. records';
my $CONNECTION_REFUSED = 'Connection refused';
my $CONNECTION_TIMEOUT = 'Connection timed out';
my $READ_TIMEOUT = 'Read timed out';
my $NAME_UNKNOWN = 'Name or service not known';

my $GET_VERSION             = 'get-version';
my $GET_EARLIEST_TIMESTAMP  = 'get-earliest-timestamp';
my $FETCH_ARCHIVE_RECORDS   = 'fetch-archive-records';
my $FETCH_TWO_MINUTE_RECORD = 'fetch-two-minute-record';
my $FETCH_CURRENT_RECORD    = 'fetch-current-record';
my $INSANE_READING          = 'Insane Reading Errors';
my $REQUEST_ERRORS          = 'Request Errors';

# any lines that do not match the patterns we define
my @unmatched = ();

# keep details
my @archive_insert_errors = ();
my @current_insert_errors = ();
my @insane_reading_errors = ();
my @two_minute_insert_errors = ();
my @request_errors = ();

my %itemized = (
    'Archive Insert Errors'   , \@archive_insert_errors,
    'Two Minute Insert Errors', \@two_minute_insert_errors,
    'Current Insert Errors'   , \@current_insert_errors,
    'Insane Reading Errors'   , \@insane_reading_errors,
    'Request Errors'          , \@request_errors,
    );

my %summaries = (
    'counts', \%counts,
    'errors', \%errors,
    );

while(defined($_ = <STDIN>)) {
    chomp;
    if (/Version *:/) {
        $counts{$STARTUPS} += 1;
    } elsif (/Event took longer than expected/) {
        $errors{$LONG_SENSOR_READS} += 1;
    } elsif (/Added record/) {
        $counts{$ARCHIVE_RECORDS_ADDED} += 1;
    } elsif (/Could not save archive reading to database/) {
        push @archive_insert_errors, $_;
        $errors{$ARCHIVE_INSERT_ERRORS} += 1;
    } elsif (/Could not save two minute reading to database/) {
        push @two_minute_insert_errors, $_;
        $errors{$TWO_MINUTE_INSERT_ERRORS} += 1;
    } elsif (/Could not save current reading to database/) {
        push @current_insert_errors, $_;
        $errors{$CURRENT_INSERT_ERRORS} += 1;
    } elsif (/Skipping reading because of: .*: Read timed out\./) {
        $errors{$READ_TIMEOUTS} += 1;
    } elsif (/Failed to establish a new connection: .* Temporary failure in name resolution/) {
        $errors{$TMP_NAME_RESOLUTON_ERRORS} += 1;
    } elsif (/Failed to establish a new connection: .* No route to host/) {
        $errors{$NO_ROUTE_TO_HOST_ERRORS} += 1;
    } elsif (/Skipping archive record because there have been zero readings this archive period/) {
        $errors{$SKIPPED_ARCHIVE_RECORDS} += 1;
    } elsif (/Connection refused.*Retrying request/) {
        $errors{$CONNECTION_REFUSED} += 1;
    } elsif (/Caused by ConnectTimeoutError/) {
        $errors{$CONNECTION_TIMEOUT} += 1;
    } elsif (/Read timed out.*Retrying request/) {
        $errors{$READ_TIMEOUT} += 1;
    } elsif (/Failed to establish a new connection: .* Name or service not known/) {
        $errors{$NAME_UNKNOWN} += 1;
    } elsif (/request_error: /) {
        push @request_errors, $_;
        $errors{$REQUEST_ERRORS} += 1;
    } elsif (/get-version: /) {
        $counts{$GET_VERSION} += 1;
    } elsif (/fetch-current-record/) {
        $counts{$FETCH_CURRENT_RECORD} += 1;
    } elsif (/fetch-two-minute-record/) {
        $counts{$FETCH_TWO_MINUTE_RECORD} += 1;
    } elsif (/fetch-archive-records/) {
        $counts{$FETCH_ARCHIVE_RECORDS} += 1;
    } elsif (/get-earliest-timestamp: /) {
        $counts{$GET_EARLIEST_TIMESTAMP} += 1;
    } elsif (/Reading found insane due to:  /) {
        $errors{$INSANE_READING} += 1;
        push @insane_reading_errors, $_;
    } elsif (/Skipping two_minute record because there have been zero readings this two minute period\./) {
        $errors{$SKIPPED_2M_RECORDS} += 1;
    } elsif (/host:port *:/ ||
             /conf_file *:/ ||
             /server_port *:/ ||
             /db_file *:/ ||
             /timeout_secs *:/ ||
             /pollfreq_secs *:/ ||
             /pollfreq_offset *:/ ||
             /arcint_secs *:/ ||
             /outfile *:/ ||
             /arcfile *:/ ||
             /service_name *:/ ||
             /pidfile *:/ ||
             /log_to_stdout *:/ ||
             /Starting .* daemon:/ ||
             /Stopping .* daemon:/ ||
             /serve_requests: port: .*, db_file_in: / ||
             /start_server: port: / ||
             /RequestType.FETCH_CURRENT_RECORD, / ||
             /debug *:/) {
        # ignore
    } else {
        push @unmatched, $_;
    }
}

foreach my $slabel (sort keys %summaries) {
    my $s = $summaries{$slabel};
    if(scalar(keys %$s)) {
        print "$slabel:\n";
        foreach my $k (sort keys %$s) {
            next if $s->{$k} == 0;
            printf("  %-45s %6d\n", $k, $s->{$k});
        }
        print "\n";
    }
}

foreach my $k (sort keys %itemized) {
    report($k, $itemized{$k}) if scalar @{$itemized{$k}} > 0;
}

report("unmatched lines", \@unmatched) if $#unmatched >= 0;

exit 0;

sub report {
    my($label, $aref, $href) = @_;
    print "\n$label:\n";
    foreach my $x (@$aref) {
        my $str = $x;
        if ($href && $href->{$x} > 1) {
            $str .= " ($href->{$x} times)";
        }
        print "  $str\n";
    }
}
